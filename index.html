<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Victor's Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Victor's Blog">
<meta property="og:description" content="blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Victor's Blog">
<meta name="twitter:description" content="blog">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Victor's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Victor's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Where miracle happens</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            標籤
          </a>
        </li>
      

      
      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">

    

    
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/27/Note-for-TSP/" itemprop="url">
                  Note for TSP
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-03-27T15:57:11+08:00" content="2016-03-27">
              2016-03-27
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/27/Note-for-TSP/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/27/Note-for-TSP/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Orienteering TSP：限制是边权和小于一个阈值，起点s终点t，目标是经过点最多<br>Weighted Orienteering TSP：限制是边权和小于一个阈值，起点s终点t，目标是点权和最大<br>    reference：<a href="http://chekuri.cs.illinois.edu/papers/orienteering-journal.pdf" target="_blank" rel="external">http://chekuri.cs.illinois.edu/papers/orienteering-journal.pdf</a><br>discounted-reward TSP：限制是有discount作用，削减点权和，目标是最大化点权和<br>    reference：Approximation Algorithms for Orienteering and Discounted-Reward TSP</p>
<p>k-stroll：限制是经过（至少？）k个点，起点s终点t，目标是最小化边权和<br>k-tour/k-TSP：k-stroll在s=t的特殊情况<br>    reference：<a href="http://ttic.uchicago.edu/~cjulia/papers/k-stroll-full.pdf" target="_blank" rel="external">http://ttic.uchicago.edu/~cjulia/papers/k-stroll-full.pdf</a><br>Generalized TSP（又叫set TSP、group TSP, One-of-a-Set TSP, Multiple Choice TSP or Covering Salesman Problem）：限制是经过每个类的一个点，成环，目标是最小化边劝和<br>    reference：<a href="http://josilber.scripts.mit.edu/GTSP.pdf" target="_blank" rel="external">http://josilber.scripts.mit.edu/GTSP.pdf</a> || <a href="https://en.wikipedia.org/wiki/Set_TSP_problem" target="_blank" rel="external">https://en.wikipedia.org/wiki/Set_TSP_problem</a></p>
<p>大一统：<br>PC-TSP family（The prize collecting traveling salesman problem）：最大化点权和，最小化边权和，两者tradeoff<br>    实际上还有一个限制是没经过的点有penalty，最小化的是cost和penalty<br>    实际上还有一个限制是点权和大于一个阈值<br>    reference：Approximation Algorithms for Orienteering and Discounted-Reward TSP及其reference 4那篇文章<br>    <a href="http://www.iasi.cnr.it/~vbonifaci/pub/pctsp-chapter.pdf" target="_blank" rel="external">http://www.iasi.cnr.it/~vbonifaci/pub/pctsp-chapter.pdf</a></p>
<pre><code>特例：
Quota TSP：penalty=0(比如k-TSP就是这个的特例)
Penalty TSP：no required quota, only penalties
</code></pre><p>其他神奇的变式：<br>    directed latency problem（又叫the deliveryman problem，the traveling repairman problem ）</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/19/Life-Experience/" itemprop="url">
                  Life Experience
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-03-19T01:27:28+08:00" content="2016-03-19">
              2016-03-19
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/19/Life-Experience/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/19/Life-Experience/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.C++一般不传裸的container或者class，用&amp;或者const &amp;！！（防止发生拷贝构造）<br>java或者其他语言？</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/10/CourseNote-Computer-Network/" itemprop="url">
                  CourseNote_Computer_Network
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-03-10T10:08:37+08:00" content="2016-03-10">
              2016-03-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/10/CourseNote-Computer-Network/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/10/CourseNote-Computer-Network/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Homework 1:<br>数据连接层(Data Link layer):dividing the transmitted bit stream into frames<br>网络层:determine the route through the subnet to use</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/08/PAT笔记/" itemprop="url">
                  PAT笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-03-08T21:14:26+08:00" content="2016-03-08">
              2016-03-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/08/PAT笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/08/PAT笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PAT1045:<br>最长公共子序列，公共部分可以元素重复，递归公式变为：<br>if a[i] == b[j]: len[i][j] = max + 1<br>else: len[i][j] = max</p>
<p>普通的LCS：<br>if a[i] == b[j]: len[i][j] = len[i][j] + 1<br>else: len[i][j] = max</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/07/PRML阅读笔记/" itemprop="url">
                  PRML阅读笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-03-07T19:03:08+08:00" content="2016-03-07">
              2016-03-07
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/07/PRML阅读笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/07/PRML阅读笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###PRML阅读笔记</p>
<p> ####多变量高斯分布<br> 数学期望推导：</p>
<ol>
<li>奇函数积分为0</li>
<li>概率密度函数积分为1</li>
</ol>
<p>二阶矩推导：<br> 方差推导：</p>
<p>条件高斯分布：<br>如果两个变量集符合联合高斯分布，那么一个变量集在另一个变量集的分布也是高斯分布<br>推导：<br>另：边缘概率分布同样符合这个性质    </p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/03/caffe-mxnet基础笔记/" itemprop="url">
                  caffe&mxnet基础笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-03-03T00:03:18+08:00" content="2016-03-03">
              2016-03-03
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/03/caffe-mxnet基础笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/03/caffe-mxnet基础笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###Note for DeepID2</p>
<p>这几天开始读Deep Learning Face Representation by Joint Identification-Verification：<a href="http://arxiv.org/abs/1406.4773" target="_blank" rel="external">http://arxiv.org/abs/1406.4773</a><br>算法流程：<br><img src="/2016/03/03/caffe-mxnet基础笔记/1.png" alt="1.png" title=""></p>
<p>Face identification是识别人是谁，相当于classification，verification是判断两个人是不是同一个人。</p>
<p>mxnet里的epoch是指训练次数，每个epoch会训练所有的数据,caffe里面没有epoch，只有snapshot参数，单位是迭代次数<br>mxnet里的checkpoint表示保存中间模型，mx.callback.do_checkpoint(path),每次epoch都会保存，caffe用snapshot这个词表达，指定每多少次迭代保存</p>
<p>Training: caffe train learns models from scratch, resumes learning from saved snapshots, and fine-tunes models to new data and tasks:</p>
<ol>
<li>All training requires a solver configuration through the -solver solver.prototxt argument.</li>
<li>Resuming requires the -snapshot model_iter_1000.solverstate argument to load the solver snapshot.</li>
<li>Fine-tuning requires the -weights model.caffemodel argument for the model initialization.</li>
</ol>
<p>caffe中：<br>Stochastic gradient descent (type: “SGD”) updates the weights W by a linear combination of the negative gradient ∇L(W) and the previous weight update V<sub>t</sub>. The learning rate α is the weight of the negative gradient. The momentum(动量) μ is the weight of the previous update.<br>Formally, we have the following formulas to compute the update value V<sub>t+1</sub> and the updated weights W<sub>t+1</sub> at iteration t+1, given the previous weight update V<sub>t</sub> and current weights WtWt:<br>V<sub>t+1</sub>=μV<sub>t</sub>−α∇L(W<sub>t</sub>)<br>W<sub>t</sub>+1=W<sub>t</sub>+V<sub>t+1</sub></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/28/resnet-mxnet/" itemprop="url">
                  resnet-mxnet
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-02-28T21:55:04+08:00" content="2016-02-28">
              2016-02-28
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/02/28/resnet-mxnet/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/02/28/resnet-mxnet/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/22/Note-for-剑指offer/" itemprop="url">
                  Note for 剑指offer
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-02-22T23:27:18+08:00" content="2016-02-22">
              2016-02-22
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/02/22/Note-for-剑指offer/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/02/22/Note-for-剑指offer/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="u5251_u6307offer_u7B14_u8BB0"><a href="#u5251_u6307offer_u7B14_u8BB0" class="headerlink" title="剑指offer笔记"></a>剑指offer笔记</h2><h3 id="Q1_uFF1A_u8D4B_u503C_u8FD0_u7B97_u7B26_u51FD_u6570"><a href="#Q1_uFF1A_u8D4B_u503C_u8FD0_u7B97_u7B26_u51FD_u6570" class="headerlink" title="Q1：赋值运算符函数"></a>Q1：赋值运算符函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#20026;class CMyString&#28155;&#21152;&#36171;&#20540;&#36816;&#31639;&#31526;&#20989;&#25968;</span><br></pre></td></tr></table></figure>
<p>注意点：</p>
<ol>
<li>是否把返回值得类型声明为该类型的引用，并在函数结束前返回实例自身的引用（即*this）。</li>
<li>是否把传入的参数的类型声明为常量引用（如果不是引用而是实例，形参到实参会调用一次复制构造函数，造成无谓消耗）</li>
<li>是否释放实例自身已有的内存（如果在分配新内存之前不释放自己已有的空间，将内存泄露）</li>
<li>是否判断传入的参数和当前的实例（*this）是不是同一个实例。</li>
</ol>
<p>初级解法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMyString&#38; CMyString::operator=(const CMyString &#38;str)&#10;&#123;&#10;if(this == &#38;str)&#10;return *this;&#10;delete []m_pData;&#10;m_pData = NULL;&#10;m_pData = new char[strlen(str.m_pData) + 1];&#10;strcpy(m_pData, str.m_pData);&#10;return *this;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>高级解法：考虑异常安全性（Exception Safety）<br>如果由于内存不足导致new char抛出异常，m_pData将是一个空指针，违背Exception Safety原则<br>两个解决方法：</p>
<ol>
<li>先用new分配内存再delete释放已有的内容，这样分配失败时未满能确保CMyString的实例不会被修改</li>
<li>先创建一个临时实例，再交换临时实例和原来的实例：</li>
</ol>
<p>方法2参考代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMyString&#38; CMyString::operator=(const CMyString &#38;str)&#10;&#123;&#10;if(this != &#38;str)&#10;&#123;&#10;CMyString strTemp(str);&#10;char * pTemp = str.m_pData;&#10;strTemp.m_pData = m_pData;&#10;m_pData = pTemp;&#10;&#125;&#10;return *this;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：程序运行到if外面就出了该变量的作用域，自动调用strTemp的析构函数</p>
<h3 id="Q4_uFF1A_u66FF_u6362_u7A7A_u683C"><a href="#Q4_uFF1A_u66FF_u6362_u7A7A_u683C" class="headerlink" title="Q4：替换空格"></a>Q4：替换空格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#23454;&#29616;&#19968;&#20010;&#20989;&#25968;&#65292;&#25226;&#23383;&#31526;&#20018;&#20013;&#30340;&#27599;&#20010;&#31354;&#26684;&#26367;&#25442;&#25104;&#34;%20&#34;</span><br></pre></td></tr></table></figure>
<p>暴力：O(n<sup>2</sup>)<br>O(n)方法：从尾部开始遍历</p>
<p>举一反三：合并两个数组时，可以考虑从后往前复制</p>
<h3 id="Q6_uFF1A_u91CD_u5EFA_u4E8C_u53C9_u6811"><a href="#Q6_uFF1A_u91CD_u5EFA_u4E8C_u53C9_u6811" class="headerlink" title="Q6：重建二叉树"></a>Q6：重建二叉树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#36755;&#20837;&#20108;&#21449;&#26641;&#30340;&#21069;&#24207;&#36941;&#21382;&#21644;&#20013;&#24207;&#36941;&#21382;&#30340;&#32467;&#26524;&#65292;&#37325;&#24314;&#20986;&#35813;&#20108;&#21449;&#26641;&#12290;</span><br></pre></td></tr></table></figure>
<h3 id="Q7_uFF1A_u7528_u4E24_u4E2A_u6808_u5B9E_u73B0_u961F_u5217"><a href="#Q7_uFF1A_u7528_u4E24_u4E2A_u6808_u5B9E_u73B0_u961F_u5217" class="headerlink" title="Q7：用两个栈实现队列"></a>Q7：用两个栈实现队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#29992;&#20004;&#20010;&#26632;&#23454;&#29616;&#38431;&#21015;&#30340;&#20004;&#20010;&#20989;&#25968;appendTail&#21644;deleteHead</span><br></pre></td></tr></table></figure>
<p>举一反三：用两个队列实现一个栈</p>
<h3 id="Q9_3A__u6590_u6CE2_u90A3_u5951_u6570_u5217"><a href="#Q9_3A__u6590_u6CE2_u90A3_u5951_u6570_u5217" class="headerlink" title="Q9: 斐波那契数列"></a>Q9: 斐波那契数列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#27714;Fibonacci&#25968;&#21015;&#30340;&#31532;n&#39033;</span><br></pre></td></tr></table></figure>
<p>用递归的方法计算的时间复杂度是以n的指数的方式递增的<br>改进：保存数列中间项，如果下次需要计算的时候先查找一下<br>另解：从下往上算，无需保存数列</p>
<p>补充：时间复杂度O(logn)但不够使用过的方法<br>利用斐波那契矩阵公式和二分法求乘方</p>
<p>Q10：二进制中1的个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#36755;&#20837;&#19968;&#20010;&#25972;&#25968;&#65292;&#36755;&#20986;&#35813;&#25968;&#20108;&#36827;&#21046;&#34920;&#31034;&#20013;1&#30340;&#20010;&#25968;</span><br></pre></td></tr></table></figure></p>
<p>版本一：可能引起死循环（why?）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int NumberOf1(int n)&#10;&#123;&#10;int count = 0;&#10;while(n)&#10;&#123;&#10;if(n&#38;1)&#10;count++;&#10;n = n &#62;&#62; 1;&#10;&#125;&#10;return count;&#10;&#125;&#10;//&#29992;&#20301;&#31227;&#21644;&#19982;&#36816;&#31639;&#20195;&#26367;&#38500;&#27861;&#21644;&#21462;&#20313;&#20248;&#21270;&#36895;&#24230;</span><br></pre></td></tr></table></figure></p>
<p>版本二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int NumberOf1(int n)&#10;&#123;&#10;int count = 0;&#10;unsigned int flag = 1;&#10;while(flag)&#10;&#123;&#10;if(n &#38; flag)&#10;count ++;&#10;flag = flag &#60;&#60; 1;&#10;&#125;&#10;return count;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>版本三:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int NumberOf1(int n)&#10;&#123;&#10;int count = 0;&#10;while(n)&#10;&#123;&#10;++ count;&#10;n = (n-1) &#38; n;&#10;&#125;&#10;return count;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Q11_uFF1A_u6570_u503C_u7684_u6574_u6570_u6B21_u65B9"><a href="#Q11_uFF1A_u6570_u503C_u7684_u6574_u6570_u6B21_u65B9" class="headerlink" title="Q11：数值的整数次方"></a>Q11：数值的整数次方</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#23454;&#29616;&#20989;&#25968;double Power(double base, int exponent)&#65292;&#19981;&#38656;&#32771;&#34385;&#22823;&#25968;&#38382;&#39064;&#12290;&#10;&#20840;&#38754;&#32780;&#39640;&#25928;&#30340;&#35299;&#27861;&#65306;</span><br></pre></td></tr></table></figure>
<p>bool g_invalidInput = false;<br>double Power(double base, int exponent)<br>{<br>g_InvalidInput = false;<br>if(equal(base,0,0) &amp;&amp; exponent &lt; 0)<br>{<br>g_InvalidInput = true;<br>return 0.0;<br>}<br>unsigned int absExpoent = (unsigned int)(exponent);<br>if(exponent &lt; 0)<br>absExponent = (unsigned int)(-exponent);<br>double result = PowerWithUnsignedExponent(base, absExponent);<br>if(exponent &lt; 0)<br>result = 1.0/result;<br>return result;<br>}</p>
<p>duoble PowerWithUnsignedExponent(double base, unsigned int exponent)<br>{<br>if(exponent == 0 )<br>return 1;<br>if(exponent == 1 )<br>return base;</p>
<p>double result = PowerWithUnsignedExponent(base,exponent&gt;&gt;1);<br>result <em>= result;<br>if(exponent &amp; 0x1 == 1)<br>result </em>= base;<br>return result;<br>}</p>
<p>bool equal(double num1, double num2)<br>{<br>if((num1-num2 &gt; -0.00000001)<br>&amp;&amp; (num1 -num2 &lt; 0.00000001))<br>return true;<br>else<br>return false;<br>}</p>
<h3 id="Q18_uFF1A_u6811_u7684_u5B50_u7ED3_u6784"><a href="#Q18_uFF1A_u6811_u7684_u5B50_u7ED3_u6784" class="headerlink" title="Q18：树的子结构"></a>Q18：树的子结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#36755;&#20837;&#20004;&#26869;&#20108;&#21449;&#26641;A&#21644;B&#65292;&#21028;&#26029;B&#26159;&#19981;&#26159;A&#30340;&#23376;&#32467;&#26500;&#65292;&#20108;&#21449;&#26641;&#32467;&#28857;&#23450;&#20041;&#22914;&#19979;&#65306;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct BinaryTreeNode&#10;&#123;&#10;int m_nValue;&#10;BinaryTreeNode* m_pLeft;&#10;BinaryTreeNode* m_pRight;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>核心代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool HasSubtree(BinaryTreeNOde* pRoot1, BinaryTreeNode* pRoot2)&#10;&#123;&#10;bool result = false;&#10;if(pRoot1 != NULL &#38;&#38; pRoot2 != NULL)&#10;&#123;&#10;if(pRoot1-&#62;m_nValue == pRoot2-&#62;m_nValue)&#10;result = DoesTree1HaveTree2(pRoot1,pRoot2);&#10;if(!result)&#10;result = HasSubtree(pRoot1-&#62;m_pLeft,pRoot2);&#10;if(!result)&#10;result = HasSubtree(pRoot1-&#62;mRight,pRoot2);&#10;&#125;&#9;&#10;return result;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Q21_uFF1A_u5305_u542Bmin_u51FD_u6570_u7684_u6808"><a href="#Q21_uFF1A_u5305_u542Bmin_u51FD_u6570_u7684_u6808" class="headerlink" title="Q21：包含min函数的栈"></a>Q21：包含min函数的栈</h3><p>定义栈的数据结构， 能在O(1)复杂度能得到栈的最小元素<br>提示：构造辅助栈</p>
<h3 id="Q24_uFF1A_u4E8C_u53C9_u641C_u7D22_u6811_u7684_u540E_u5E8F_u904D_u5386_u5E8F_u5217"><a href="#Q24_uFF1A_u4E8C_u53C9_u641C_u7D22_u6811_u7684_u540E_u5E8F_u904D_u5386_u5E8F_u5217" class="headerlink" title="Q24：二叉搜索树的后序遍历序列"></a>Q24：二叉搜索树的后序遍历序列</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。假设输入的数组的任意两个数字不相同。<br>类似的：前序遍历<br>方法参考Q6</p>
<h3 id="Q25_uFF1A_u4E8C_u53C9_u6811_u4E2D_u548C_u4E3A_u67D0_u4E00_u503C_u5F97_u8DEF_u5F84"><a href="#Q25_uFF1A_u4E8C_u53C9_u6811_u4E2D_u548C_u4E3A_u67D0_u4E00_u503C_u5F97_u8DEF_u5F84" class="headerlink" title="Q25：二叉树中和为某一值得路径"></a>Q25：二叉树中和为某一值得路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#36755;&#20837;&#19968;&#26869;&#20108;&#21449;&#26641;&#21644;&#19968;&#20010;&#25972;&#25968;&#65292;&#25171;&#21360;&#20986;&#20108;&#21449;&#26641;&#20013;&#32467;&#28857;&#20540;&#30340;&#21644;&#20026;&#36755;&#20837;&#25972;&#25968;&#30340;&#25152;&#26377;&#36335;&#24452;&#12290;&#20174;&#26641;&#30340;&#26681;&#32467;&#28857;&#24320;&#22987;&#24448;&#19979;&#19968;&#30452;&#21040;&#21494;&#23376;&#32467;&#28857;&#25152;&#32463;&#36807;&#30340;&#32467;&#28857;&#24418;&#25104;&#19968;&#26465;&#36335;&#24452;&#12290;</span><br></pre></td></tr></table></figure>
<p>ps：如果结点没有指向父结点的职责恩，我们可以在遍历的时候用一个栈lai来保存从根结点到当前结点的路径</p>
<h3 id="Q27_uFF1A_u4E8C_u53C9_u641C_u7D22_u6811_u4E0E_u53CC_u5411_u94FE_u8868"><a href="#Q27_uFF1A_u4E8C_u53C9_u641C_u7D22_u6811_u4E0E_u53CC_u5411_u94FE_u8868" class="headerlink" title="Q27：二叉搜索树与双向链表"></a>Q27：二叉搜索树与双向链表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#36755;&#20837;&#19968;&#26869;&#20108;&#21449;&#25628;&#32034;&#26641;&#65292;&#23558;&#35813;&#20108;&#21449;&#25628;&#32034;&#26641;&#36716;&#25442;&#25104;&#19968;&#20010;&#25490;&#24207;&#30340;&#21452;&#21521;&#38142;&#34920;&#12290;&#35201;&#27714;&#19981;&#33021;&#21019;&#24314;&#20219;&#20309;&#26032;&#30340;&#32467;&#28857;&#12290;</span><br></pre></td></tr></table></figure>
<p>参考代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BinaryTreeNode* Convert(BinaryTreeNode* pRootOfTree)&#10;&#123;&#10;BinaryTreeNode *pLastNodeInList = NULL;&#10;ConvertNode(pRootOfTree,&#38;pLastNodeInList);&#10;&#10;//&#36890;&#36807;&#23614;&#32467;&#28857;&#24471;&#21040;&#22836;&#32467;&#28857;&#10;BinaryTreeNode *pHeadOfList =pLastNodeInList;&#10;while(pHeadOfList != NULL &#38;&#38; pHeadOfList -&#62; m_pLeft != NULL)&#10;pHeadOfList = pHeadOfList-&#62;m_pList;&#10;return pHeadOfList;&#10;&#125;&#10;&#10;void ConvertNode(BinaryTreeNode* pNode, BinaryTreeNode** pLastNodeInList)&#10;&#123;&#10;if(pNode == NULL)&#10;return;&#10;BinaryTreeNode * pCurrent = pNode;&#10;if(pCurrent-&#62;m_pLeft!=NULL)&#10;ConvertNode(pCurrent-&#62;m_pLeft,pLastNodeInList);&#10;&#10;pCurrent-&#62;m_pLeft = *pLastNodeInList;&#10;if(*pLastNodeInList != NULL)&#10;(*pLastNodeInList)-&#62;m_pRight = pCurrent;&#10;&#10;*pLastNodeInList = pCurrent;&#10;&#10;if(pCurrent-&#62;m_pRight != NULL)&#10;ConvertNode(pCurrent-&#62;m_pRight, pLastNodeInList);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Q28_uFF1A_u5B57_u7B26_u4E32_u7684_u6392_u5217"><a href="#Q28_uFF1A_u5B57_u7B26_u4E32_u7684_u6392_u5217" class="headerlink" title="Q28：字符串的排列"></a>Q28：字符串的排列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#36755;&#20837;&#19968;&#20010;&#23383;&#31526;&#20018;&#65292;&#25171;&#21360;&#20986;&#35813;&#23383;&#31526;&#20018;&#20013;&#23383;&#31526;&#30340;&#25152;&#26377;&#25490;&#21015;</span><br></pre></td></tr></table></figure>
<p>参考代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Permutation(char* pStr)&#10;&#123;&#10;if(pStr == NULL)&#10;return;&#10;Permutation(pStr,pStr);&#10;&#125;&#10;&#10;void Permutation(char* pStr, char* pBegin)&#10;&#123;&#10;if(*pBegin == &#39;\0&#39;)&#10;printf(&#34;%s\n&#34;,pStr);&#10;else&#10;&#123;&#10;for(char* pCh = pBegin; *pCh != &#39;\0&#39;; ++ pCh)&#10;&#123;&#10;char temp = *pCh;&#10;*pCh = *pBegin;&#10;*pBegin = temp;&#10;Permutation(pStr,pBegin + 1);&#10;temp = *pCh;&#10;*pCh = *pBegin;&#10;*pBegin = temp;&#10;&#125;&#10;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>举一反三：求字符的所有组合（比如输入三个字符a、b、c，则他们的组合有a、b、c、ab、ac、bc、abc）</p>
<p>提示：在求n个字符的长度为m的组合的时候，分别求n-1个字符串中长度为m-1的组合，以及求n-1个字符的长度为m的组合。</p>
<h3 id="Q30_uFF1A_u6700_u5C0F_u7684k_u4E2A_u6570"><a href="#Q30_uFF1A_u6700_u5C0F_u7684k_u4E2A_u6570" class="headerlink" title="Q30：最小的k个数"></a>Q30：最小的k个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#36755;&#20837;n&#20010;&#25972;&#25968;&#65292;&#25214;&#20986;&#20854;&#20013;&#30340;&#26368;&#23567;&#30340;k&#20010;&#25968;&#12290;</span><br></pre></td></tr></table></figure>
<p>解法一：基于Partition函数的方法，O(n)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#23454;&#29616;&#24555;&#36895;&#25490;&#24207;&#30340;&#20851;&#38190;&#65306;&#20808;&#22312;&#25968;&#32452;&#20013;&#36873;&#25321;&#19968;&#20010;&#25968;&#23383;&#65292;&#25509;&#19979;&#26469;&#25226;&#25968;&#32452;&#20013;&#30340;&#25968;&#23383;&#20998;&#20026;&#20004;&#37096;&#20998;&#65292;&#27604;&#36873;&#25321;&#30340;&#25968;&#23383;&#23567;&#30340;&#25968;&#23383;&#31227;&#21040;&#25968;&#32452;&#30340;&#24038;&#36793;&#65292;&#27604;&#36873;&#25321;&#30340;&#25968;&#23383;&#22823;&#30340;&#25968;&#23383;&#31227;&#21040;&#25968;&#32452;&#30340;&#21491;&#36793;&#12290;&#10;int Partition(int data[], int length, int start, int end)&#10;&#123;&#10;if(data == NULL || length &#60;= 0 || start &#60;0 || end &#62;= length)&#10;throw new std::exception(&#34;Invalid Parameters&#34;);&#10;int index = RandomInRange(start, end);&#10;Swap(&#38;data[index],&#38;data[end]);&#10;&#10;int small = start - 1;&#10;for(index = start; index &#60; end; ++ index)&#10;&#123;&#10;if(data[index]&#60;data[end])&#10;&#123;&#10;++ small;&#10;if(small != index)&#10;Swap(&#38;data[index],&#38;data[small]);&#10;&#125;&#10;&#125;_&#10;++small;&#10;Swape(&#38;data[small],&#38;data[end]);&#10;return small;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>解法二：维护一个最大堆（放k个数的容器，在O(1)时间找到最大值，O(logn)时间删除最大数，插入新的数字），复杂度O(nlogn)<br>两个优点：</p>
<ol>
<li>没有修改输入的数据</li>
<li>只要求内存能容纳k个数，不必把n个数据一次载入内存，适合海量数据的输入</li>
</ol>
<h3 id="Q36_uFF1A_u6570_u7EC4_u4E2D_u7684_u9006_u5E8F_u5BF9"><a href="#Q36_uFF1A_u6570_u7EC4_u4E2D_u7684_u9006_u5E8F_u5BF9" class="headerlink" title="Q36：数组中的逆序对"></a>Q36：数组中的逆序对</h3><p>在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。<br>提示：类似于归并排序</p>
<h3 id="Q37_uFF1A_u4E24_u4E2A_u94FE_u8868_u7684_u7B2C_u4E00_u4E2A_u516C_u5171_u7ED3_u70B9"><a href="#Q37_uFF1A_u4E24_u4E2A_u94FE_u8868_u7684_u7B2C_u4E00_u4E2A_u516C_u5171_u7ED3_u70B9" class="headerlink" title="Q37：两个链表的第一个公共结点"></a>Q37：两个链表的第一个公共结点</h3><p>输入两个链表，找出他们的第一个公共结点<br>暴力：O(mn)<br>构造两个辅助栈，从后往前找：O(m+n)<br>优化：先遍历一次找出长度的差值，第二次遍历时，较长的链表先走那么多步，再同时遍历，O(m+n)</p>
<h3 id="Q39_uFF1A_u4E8C_u53C9_u6811_u7684_u6DF1_u5EA6"><a href="#Q39_uFF1A_u4E8C_u53C9_u6811_u7684_u6DF1_u5EA6" class="headerlink" title="Q39：二叉树的深度"></a>Q39：二叉树的深度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#36755;&#20837;&#19968;&#26869;&#20108;&#21449;&#26641;&#30340;&#26681;&#32467;&#28857;&#65292;&#27714;&#35813;&#26641;&#30340;&#28145;&#24230;&#12290;</span><br></pre></td></tr></table></figure>
<p>引申：输入一棵二叉树的根结点，判断该树是不是平衡二叉树。</p>
<p>方法一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool IsBalanced(BinaryTreeNode* pRoot)&#10;&#123;&#10;if(pRoot == NULL)&#10;return true;&#10;int left = TreeDepth(pRoot-&#62;m_pLeft);&#10;int right = TreeDepth(pRoot-&#62;m_pRight);&#10;int diff = left -right;&#10;if(diff &#62; 1 || diff &#60; -1)&#10;return false;&#10;return IsBalanced(pRoot-&#62;m_pLeft) &#38;&#38; IsBalanced(pRoot-&#62;m_pRight);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个节点都会被重复遍历多次，效率不高</p>
<p>方法二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool IsBalanced(BinaryTreeNOde* pRoot, int* pDepth)&#10;&#123;&#10;if(pRoot == NULL)&#10;&#123;&#10;*pDepth = 0;&#10;return true;&#10;&#125;&#10;int left,right;&#10;if(IsBalanced(pRoot-&#62;m_pLeft,&#38;left)&#38;&#38;IsBalanced(pRoot-&#62;m_pRight,&#38;right))&#10;&#123;&#10;int diff = left - right;&#10;if(diff &#60;= 1 &#38;&#38; diff &#62;= -1)&#10;&#123;&#10;*pDepht = 1 + (left &#62; right ? left : right);&#10;return true;_&#10;&#125;&#10;&#125;&#10;return false;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们只需给上面的函数传入二叉树的根结点及一个表示结点深度的整型变量即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool IsBalanced(BinaryTreeNode* pRoot)&#10;&#123;&#10;int depth = 0;&#10;return IsBalanced(pRoot, &#38;depth);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Q40_uFF1A_u6570_u7EC4_u4E2D_u53EA_u51FA_u73B0_u4E00_u6B21_u7684_u6570_u5B57"><a href="#Q40_uFF1A_u6570_u7EC4_u4E2D_u53EA_u51FA_u73B0_u4E00_u6B21_u7684_u6570_u5B57" class="headerlink" title="Q40：数组中只出现一次的数字"></a>Q40：数组中只出现一次的数字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#19968;&#20010;&#25972;&#22411;&#25968;&#32452;&#37324;&#38500;&#20102;&#20004;&#20010;&#25968;&#23383;&#20043;&#22806;&#65292;&#20854;&#20182;&#30340;&#25968;&#23383;&#37117;&#20986;&#29616;&#20004;&#27425;&#12290;&#25214;&#20986;&#36825;&#36830;&#20010;&#21482;&#20986;&#29616;&#19968;&#27425;&#30340;&#25968;&#23383;&#12290;&#35201;&#27714;&#26102;&#38388;&#22797;&#26434;&#24230;&#26159;O(n)&#65292;&#31354;&#38388;&#22797;&#26434;&#24230;&#26159;O(1)&#12290;</span><br></pre></td></tr></table></figure>
<p>提示：异或的性质<br>全部取异或之后按第一个1的位置是不是1将原数组中的数字分为两个子数组，在分别异或。</p>
<h3 id="Q41_uFF1A_u548C_u4E3As_u7684_u4E24_u4E2A_u6570_u5B57-_26gt_3B_u548C_u4E3As_u7684_u8FDE_u7EED_u6B63_u6574_u6570_u5E8F_u5217"><a href="#Q41_uFF1A_u548C_u4E3As_u7684_u4E24_u4E2A_u6570_u5B57-_26gt_3B_u548C_u4E3As_u7684_u8FDE_u7EED_u6B63_u6574_u6570_u5E8F_u5217" class="headerlink" title="Q41：和为s的两个数字-&gt;和为s的连续正整数序列"></a>Q41：和为s的两个数字-&gt;和为s的连续正整数序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#36755;&#20837;&#19968;&#20010;&#22320;&#38663;&#25490;&#24207;&#30340;&#25968;&#32452;&#21644;&#19968;&#20010;&#25968;&#23383;s&#65292;&#22312;&#25968;&#32452;&#20013;&#26597;&#25214;&#20004;&#20010;&#25968;&#65292;&#20351;&#24471;&#20182;&#20204;&#30340;&#21644;&#27491;&#22909;&#26159;s&#12290;&#22914;&#26524;&#26377;&#22810;&#23545;&#25968;&#23383;&#30340;&#21644;&#26159;s&#65292;&#36755;&#20986;&#20219;&#24847;&#19968;&#23545;&#21363;&#21487;&#12290;</span><br></pre></td></tr></table></figure>
<p>规律：O(n)复杂度，一般都要想出两个指针来做<br>变式：输入一个整数s，打印出所有和为s的连续正整数序列（至少有两个数）</p>
<h3 id="Q42_uFF1A_u7FFB_u8F6C_u5355_u8BCD_u987A_u5E8F-_26gt_3B_u5DE6_u65CB_u8F6C_u5B57_u7B26_u4E32"><a href="#Q42_uFF1A_u7FFB_u8F6C_u5355_u8BCD_u987A_u5E8F-_26gt_3B_u5DE6_u65CB_u8F6C_u5B57_u7B26_u4E32" class="headerlink" title="Q42：翻转单词顺序-&gt;左旋转字符串"></a>Q42：翻转单词顺序-&gt;左旋转字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#36755;&#20837;&#19968;&#20010;&#33521;&#25991;&#21477;&#23376;&#65292;&#32763;&#36716;&#21333;&#35789;&#30340;&#39034;&#24207;&#65292;&#20294;&#21333;&#35789;&#20869;&#23383;&#31526;&#30340;&#39034;&#24207;&#19981;&#21464;&#12290;</span><br></pre></td></tr></table></figure>
<p>变式：定义一个函数实现字符串左旋转的功劳，比如输入字符串”abcdefg”和数字2，该函数将返回左旋转2位得到的结果”cdefgab”。</p>
<h3 id="Q43_uFF1An_u4E2A_u9AB0_u5B50_u7684_u70B9_u6570"><a href="#Q43_uFF1An_u4E2A_u9AB0_u5B50_u7684_u70B9_u6570" class="headerlink" title="Q43：n个骰子的点数"></a>Q43：n个骰子的点数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#25226;n&#20010;&#39600;&#23376;&#25172;&#22312;&#22320;&#19978;&#65292;&#25152;&#26377;&#39600;&#23376;&#26397;&#19978;&#19968;&#38754;&#30340;&#28857;&#25968;&#20043;&#21644;&#20026;s&#65292;&#36755;&#20837;n&#65292;&#25171;&#21360;s&#30340;&#25152;&#26377;&#21487;&#33021;&#30340;&#20540;&#20986;&#29616;&#30340;&#27010;&#29575;&#12290;</span><br></pre></td></tr></table></figure>
<h3 id="Q49_uFF1A_u628A_u5B57_u7B26_u4E32_u8F6C_u6362_u6210_u6574_u6570"><a href="#Q49_uFF1A_u628A_u5B57_u7B26_u4E32_u8F6C_u6362_u6210_u6574_u6570" class="headerlink" title="Q49：把字符串转换成整数"></a>Q49：把字符串转换成整数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum StatusP&#123;kValid = 0, kInvalid&#125;;&#10;int g_nStatus = kValid;&#10;int StrToInt(const char* str)&#10;&#123;&#10;g_nStatus = kInvalid;&#10;long long num = 0;&#10;if(str != NULL &#38;&#38; *str != &#39;\0&#39;)&#10;&#123;&#10;bool minus = false;&#10;if(*str == &#39;+&#39;)&#10;str++;&#10;else if(*str == &#39;-&#39;)&#10;&#123;&#10;str ++;&#10;minus = true;&#10;&#125;&#10;if(*str != &#39;\0&#39;)&#10;&#123;&#10;num = StrToIntCore(str,minus);&#10;&#125;&#10;&#125;&#10;return (int)num;&#10;&#125;&#10;&#10;long long StrToIntCore(const char* digit, bool minus)&#10;&#123;&#10;long long num = 0;&#10;while(*digit != &#39;\0&#39;)&#10;&#123;&#10;if(*digit &#62;= &#39;0&#39; &#38;&#38; *digit &#60;= &#39;9&#39;)&#10;&#123;&#10;int flag = minus?-1:1;&#10;num = num * 10 + flag * (*digit - &#39;0&#39;);&#10;if((!minus &#38;&#38; num &#62; 0x7FFFFFFF)&#10;|| (minus &#38;&#38; num &#60; (signed int)0x80000000))&#10;&#123;&#10;num = 0;&#10;break;&#10;&#125;&#10;digit++;&#10;&#125;&#10;else&#10;&#123;&#10;num ++;&#10;break;&#10;&#125;&#10;if(*digit == &#39;\0&#39;)&#10;&#123;&#10;g_nStatus = kValid;&#10;&#125;&#10;return num;&#10;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Q50_uFF1A_u6811_u4E2D_u4E24_u4E2A_u7ED3_u70B9_u7684_u6700_u4F4E_u516C_u5171_u7956_u5148"><a href="#Q50_uFF1A_u6811_u4E2D_u4E24_u4E2A_u7ED3_u70B9_u7684_u6700_u4F4E_u516C_u5171_u7956_u5148" class="headerlink" title="Q50：树中两个结点的最低公共祖先"></a>Q50：树中两个结点的最低公共祖先</h3><p>情况一：二叉搜索树<br>情况二：普通的树有指向父亲结点的指针（转换成类似Q37的题目）<br>情况三：普通的树没有指向父亲结点的指针（可以考虑辅助内存，遍历两次树，时间复杂度O(n)，空间复杂度O(logn)）</p>
<h3 id="C++_u8BED_u6CD5_u8865_u5145"><a href="#C++_u8BED_u6CD5_u8865_u5145" class="headerlink" title="C++语法补充"></a>C++语法补充</h3><ol>
<li><p>含有指针成员的类一般要自己写拷贝构造函数或者拷贝运算符的重载函数，否则在编译器生成的缺省的构造拷贝函数和拷贝运算符的重载函数，对指针实行的是按位拷贝，仅仅是拷贝指针的地址，而不会拷贝指针的内容。另一种解决办法是禁用这两个函数，如果类的用户企图调用这两个函数，将不能通过编译。实现的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private:&#10;Array(const Array&#38; copy);&#10;const Array&#38; operator=(const Array&#38; copy);</span><br></pre></td></tr></table></figure>
</li>
<li><p>const和static不能同时修饰类的成员函数。C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的const this*。但当一个成员为static的时候，该函数是没有this指针的。</p>
</li>
<li>C++中，成员变量的初始化顺序只与它们在类中声明的顺序有关，而与在初始化列表中的顺序无关。</li>
</ol>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/10/Classification-Retrieval/" itemprop="url">
                  Classification_Retrieval
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-02-10T11:08:07+08:00" content="2016-02-10">
              2016-02-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/02/10/Classification-Retrieval/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/02/10/Classification-Retrieval/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="classification_u4E0Eretrieval_u95EE_u9898_u5BF9_u6BD4"><a href="#classification_u4E0Eretrieval_u95EE_u9898_u5BF9_u6BD4" class="headerlink" title="classification与retrieval问题对比"></a>classification与retrieval问题对比</h3><img src="/2016/02/10/Classification-Retrieval/1.png" alt="1.png" title="">
<ol>
<li>如果直接用NN的方法，会找到1的错误结果；如果用svm（一般分类的方法），可以分出1这个outlier</li>
<li>classification的训练过程对排除outlier很有用；Retrieval中没有类这个定义，每个图像都是一个单独的个体，一般不进行训练，因为无法得到数据库的标签，这是和classification的本质不同</li>
<li>数据集来自indoor-67，每个图片已经赋予了一定的描述向量</li>
</ol>
<h3 id="u7528classification_u7684_u65B9_u6CD5_u89E3_u51B3retrieval_u95EE_u9898"><a href="#u7528classification_u7684_u65B9_u6CD5_u89E3_u51B3retrieval_u95EE_u9898" class="headerlink" title="用classification的方法解决retrieval问题"></a>用classification的方法解决retrieval问题</h3><img src="/2016/02/10/Classification-Retrieval/2.png" alt="2.png" title="">
<img src="/2016/02/10/Classification-Retrieval/3.png" alt="3.png" title="">
<ol>
<li>把每个图定义为一个类别，每个图的子patch作为该类的“图片”，提取该“图片”的特征放到特征空间如图，用image-class距离作为query图与数据库中图片的距离</li>
<li>这种距离的计算方法类似于KNN</li>
</ol>
<h3 id="u590D_u6742_u5EA6_u5206_u6790"><a href="#u590D_u6742_u5EA6_u5206_u6790" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><img src="/2016/02/10/Classification-Retrieval/4.png" alt="4.png" title="">
<img src="/2016/02/10/Classification-Retrieval/5.png" alt="5.png" title="">
<ol>
<li>计算图间距离比普通的方法大了K^2倍，改用PCA和PQ降低复杂度</li>
<li>算法复杂度仍是瓶颈</li>
<li>PQ的算法见paper：<a href="https://lear.inrialpes.fr/pubs/2011/JDS11/jegou_searching_with_quantization.pdf" target="_blank" rel="external">https://lear.inrialpes.fr/pubs/2011/JDS11/jegou_searching_with_quantization.pdf</a></li>
<li>常见近邻算法：<a href="http://blog.csdn.net/guoyilin/article/details/39668183" target="_blank" rel="external">http://blog.csdn.net/guoyilin/article/details/39668183</a></li>
</ol>
<p>注:内容主要参考清华大学Lingxi Xie博士的报告及其论文(<a href="http://vision.ouc.edu.cn/valse/videos/VALSE20150722-PaperReading-LiuGuangcan_XieLingxi-NUIST_TSINGHUA-publish.mp4" target="_blank" rel="external">http://vision.ouc.edu.cn/valse/videos/VALSE20150722-PaperReading-LiuGuangcan_XieLingxi-NUIST_TSINGHUA-publish.mp4</a> 、 <a href="http://bigml.cs.tsinghua.edu.cn/~lingxi/PDFs/Xie_ICMR15_ONE.pdf" target="_blank" rel="external">http://bigml.cs.tsinghua.edu.cn/~lingxi/PDFs/Xie_ICMR15_ONE.pdf</a>)</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/08/CFSS/" itemprop="url">
                  CFSS
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-02-08T11:52:12+08:00" content="2016-02-08">
              2016-02-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/02/08/CFSS/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/02/08/CFSS/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="3000-fps-cvpr14_u7684_u65B9_u6CD5_3A"><a href="#3000-fps-cvpr14_u7684_u65B9_u6CD5_3A" class="headerlink" title="3000-fps-cvpr14的方法:"></a>3000-fps-cvpr14的方法:</h2><p><a href="http://research.microsoft.com/en-us/people/yichenw/cvpr14_facealignment.pdf" target="_blank" rel="external">http://research.microsoft.com/en-us/people/yichenw/cvpr14_facealignment.pdf</a><br>整个流程基于Cascade Pose Regression(<a href="http://vision.ucsd.edu/~pdollar/files/papers/DollarCVPR10pose.pdf" target="_blank" rel="external">http://vision.ucsd.edu/~pdollar/files/papers/DollarCVPR10pose.pdf</a>)，训练步骤如下：(参考xbb学长的博客<a href="http://freesouls.github.io/2015/06/07/face-alignment-local-binary-feature/" target="_blank" rel="external">http://freesouls.github.io/2015/06/07/face-alignment-local-binary-feature/</a>)</p>
<h3 id="u7279_u5F81_u63D0_u53D6"><a href="#u7279_u5F81_u63D0_u53D6" class="headerlink" title="特征提取"></a>特征提取</h3><ol>
<li>先random产生500个pixel difference features</li>
<li>选取最具有分辨力的pixel difference features作为Random Forest中每棵树中的非叶子结点</li>
<li>输入图片得到Local Binary Features<br>一句话就是通过PDF+RF得到了一个稀疏的特征<br>特征提取方法来自于一篇cvpr12：<a href="http://research.microsoft.com/pubs/192097/cvpr12_facealignment.pdf" target="_blank" rel="external">http://research.microsoft.com/pubs/192097/cvpr12_facealignment.pdf</a><h3 id="u56DE_u5F52"><a href="#u56DE_u5F52" class="headerlink" title="回归"></a>回归</h3><img src="/2016/02/08/CFSS/1454664119237.png" alt="1454664119237.png" title="">
没有发现很特殊的地方？</li>
</ol>
<h2 id="CFSS_u7684_u65B9_u6CD5_uFF1A"><a href="#CFSS_u7684_u65B9_u6CD5_uFF1A" class="headerlink" title="CFSS的方法："></a>CFSS的方法：</h2><img src="/2016/02/08/CFSS/1454660991747.png" alt="1454660991747.png" title="">
<p>注意：</p>
<ol>
<li>L=stageTot=3 每个stage之间用的Pr不同</li>
<li>stage内部也有3次迭代，训练的是三个不同的回归模型，10张脸经过3次不同的回归得到10张新脸，然后poseVoting函数算出平均脸（这个函数里面有个100次迭代的算法，详见论文及其引用）</li>
<li>Pr的计算在算出新一波的sub-region center 之后进行，原理主要是那几个公式，概率估计，用的是那10个脸的坐标变化值的数据？我们做的时候可以用距离1500-1510和100-110这两个代替（第一个stage用的是随机的10张脸）</li>
<li>第5行Kl=132，第二点说到的一个回归模型是由132个regressor组成的，每一个regressor的回归自变量是一幅图所有landmark点的特征的连接，因变量是某一个landmark的坐标改变量，总共有31480（10*N）个point用于回归，方法是岭回归（线性回归的一种）</li>
<li>3000-fps那篇论文的方法更加general&amp;simple（相比于这篇）的方法，stage内部没有多次迭代，直接一幅图的landmark feature连接回归到一个landmark的坐标该变量作为一个regressor，总共有N个这样的point用于回归，每个stage回归出一个模型，并不需要求平均脸，直接取最后一次回归结果加上上一次的人脸？</li>
</ol>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.jpg"
               alt="Victor Yang" />
          <p class="site-author-name" itemprop="name">Victor Yang</p>
          <p class="site-description motion-element" itemprop="description">blog</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">13</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">1</span>
              <span class="site-state-item-name">分類</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Victor Yang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zjuvblog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  

  
  


</body>
</html>
