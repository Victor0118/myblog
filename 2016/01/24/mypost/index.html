<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>mypost | Victor's blog</title><meta name="description"><meta name="generator" content="Victor's blog"><meta name="author" content="Victor Yang"><meta name="keywords" content="sjaak van den berg, svdb, bitcoin, crypto, payment, integration, bitcoins, wordpress, betaling, webshop, front end, design, ontwerp, developer"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-180x180.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="160x160" href="/images/favicon-160x160.png"><link rel="icon" type="image/png" sizes="192x192" href="/images/favicon-192x192.png"><meta name="msapplication-TileColor" content="#121315"><meta name="msapplication-TileImage" content="/images/mstile-144x144.png"></head><body itemscope itemtype="https://schema.org/WebPage"><header itemscope itemtype="https://schema.org/WPHeader"><a href="/"><img src="/images/svdb.png" alt="Victor's blog" title="Victor's blog"></a><h1><a href="/" alt="Victor's blog" title="Victor's blog" itemprop="headline">Victor's blog</a></h1><p itemprop="description">blog</p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name"><a href="/" alt="Home" title="Home" itemprop="url">Home</a></li><li itemprop="name"><a href="/articles" alt="Articles" title="Articles" itemprop="url">Articles</a></li><li itemprop="name"><a href="/about" alt="About" title="About" itemprop="url">About</a></li></ul></nav><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><article class="full"><h1 itemprop="headline">mypost</h1><span class="post-meta">Published on<time itemprop="datePublished" datetime="2016-01-24T04:36:01.000Z"> 星期日, 一月 24日 2016 at 12:36</time><br>Last updated on<time itemprop="dateModified" datetime="2016-01-24T04:36:01.000Z"> 星期日, 一月 24日 2016 at 14:30</time></span><p>##################### </p>
<h4 id="Linux_u547D_u4EE4"><a href="#Linux_u547D_u4EE4" class="headerlink" title="Linux命令"></a><strong>Linux命令</strong></h4><p>mount<br>cp：将一个档案copy到另一档案，或将数个档案copy至另一目录<br>通过VFS提供的系统调用接口进行文件操作<br>pwd：<br>cat<br>grep<br>find<br>ls<br>man: 帮助手册的章节，1-用户命令，2-系统调用，5-文件格式，8-关于系统维护的命令</p>
<h4 id="Linux_u7F16_u8BD1_u57FA_u672C_u547D_u4EE4"><a href="#Linux_u7F16_u8BD1_u57FA_u672C_u547D_u4EE4" class="headerlink" title="Linux编译基本命令"></a>Linux编译基本命令</h4><p>make<br>config</p>
<h4 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>/proc</strong>：虚拟文件系统，在这里可以获取系统状态信息并且修改系统的某些配置信息<br>如内存情况在/proc/meminfo文件中<br>vfs：存在于内存空间，根据不同的文件系统抽象出了一个通用的文件模型，由四种数据对象组成：</p>
<ul>
<li>超级块对象superblock：存储已安装文件系统的信息，通常对应磁盘文件系统的文件系统超级块或者控制块</li>
<li>索引节点对象inode object：存储某个文件的信息。通常对应磁盘文件系统的文件控制块。</li>
<li>目录项对象dentry object：dentry对象主要是描述一个目录项，是路径的组成部分。</li>
<li>文件对象file object：存储一个打开文件和一个进程的关联信息。只要文件一直打开，这个对象就一直存在。<br>task_struct：进程控制块PCB，是进程存在的唯一标志。</li>
</ul>
<ul>
<li>struct mm_struct *mm //进程的虚存信息</li>
<li>struct fs_struct *fs //进程的可执行映象所在的文件系统</li>
<li>struct files_struct *files //进程打开的文件</li>
</ul>
<h4 id="u5185_u6838_u7F16_u8BD1"><a href="#u5185_u6838_u7F16_u8BD1" class="headerlink" title="内核编译"></a><strong>内核编译</strong></h4><p>添加系统调用mysyscall：每发生一次缺页都要进入缺页中断服务函数do_page_fault一次，所以可以认为该函数的次数就是发生缺页的次数</p>
<p>####<strong>缺页中断调用机理</strong><br>缺页中断矢量设置（3分）<br>区分是页面异常（地址非法，访问权限等）还是缺页（3分）<br>Linux的页面管理，虚拟地址段管理，换页等（4分）</p>
<p>####<strong>进程状态转换</strong><br>进程是由正文段、用户数据段和系统数据段、堆栈段组成的一个动态实体<br><img src="http://img.blog.csdn.net/20160122181837627" alt="这里写图片描述"></p>
<h4 id="fork_uFF08_uFF09_u51FD_u6570_u8FDB_u7A0B_u521B_u5EFA_u8FC7_u7A0B"><a href="#fork_uFF08_uFF09_u51FD_u6570_u8FDB_u7A0B_u521B_u5EFA_u8FC7_u7A0B" class="headerlink" title="fork（）函数进程创建过程"></a><strong>fork（）函数进程创建过程</strong></h4><ul>
<li>为新进程分配task_struct内存空间</li>
<li>把父进程task_struct拷贝到子进程的task_struct</li>
<li>为新进程在其虚拟内存建立内核堆栈</li>
<li>对子进程task_struct中部分进行初始化设置</li>
<li>把父进程的有关信息拷贝给子进程，建立共享关系</li>
<li>把子进程的counter设为父进程counter值的一半</li>
<li>把子进程加入到可运行队列中</li>
<li>结束do_fork（）函数返回PID值</li>
</ul>
<h4 id="do_fork_uFF08_uFF09_u51FD_u6570"><a href="#do_fork_uFF08_uFF09_u51FD_u6570" class="headerlink" title="do_fork（）函数"></a><strong>do_fork（）函数</strong></h4><p>三个系统调用实现创建子进程都会调用do_fork（）函数</p>
<ul>
<li>sys_clone（）：对应的clone_flags可能是多个标志位的组合，取决于具体情况</li>
<li>sys_vfork（）：对应的clone_flags值是SIGCHIILD。SIGCHILD的作用是子进程终结或暂停时给父进程发信号。</li>
<li>sys_fork（）：对应的clone_flags值是CLONE_VFORK|CLONE_VM|SIGCHILD</li>
</ul>
<p>do_fork（）的执行过程</p>
<ul>
<li>调用alloc_task_struct（）分配子进程task_struct空间。</li>
<li>把父进程task_struct的值全部赋给子进程task_struct。</li>
<li>检查是否超过了资源限制，如果是，则结束并返回出错信息。更改一些统计量的信息。</li>
<li>修改子进程task_struct的某些成员的值使其正确反映子进程的状况，如进程状态被置成TASK_UNINTERRUPTIBLE。</li>
<li>调用get_pid（）函数为子进程得到一个pid号。</li>
<li>共享或复制父进程文件处理、信号处理及进程虚拟地址空间等资源。</li>
<li>调用copy_process（）初始化子进程的内核栈，内核栈保存了进程返回用户空间的上文。（以i386为例，其中很重要的一点是寄存器eax值的位置被置0，这个值就是执行系统调用后子进程的返回值。）</li>
<li>将父进程的当前的时间配额counter分一半给子进程。</li>
<li>利用宏SET_LINKS将子进程插入所有进程都在其中的双向链表。调用hash_pid（），将子进程加入相应的hash队列。</li>
<li>调用wake_up_process（），将该子进程插入可运行队列。至此，子进程创建完毕，并在可运行队列中等待被调度执行。</li>
<li>如果clone_flags包含有CLONE_VFORK标志，则将父进程挂起直到子进程释放进程空间。（进程控制块中有 一个信号量vfork_sem可以起到将进程挂起的作用。）</li>
<li>返回子进程的pid值，该值就是系统调用后父进程的返回值。</li>
</ul>
<p><img src="http://img.blog.csdn.net/20160122184943498" alt="这里写图片描述"></p>
<h4 id="u6587_u4EF6_u7CFB_u7EDFmount_u547D_u4EE4"><a href="#u6587_u4EF6_u7CFB_u7EDFmount_u547D_u4EE4" class="headerlink" title="文件系统mount命令"></a><strong>文件系统mount命令</strong></h4><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [-t fstype] [-o options] device dirname</span><br></pre></td></tr></table></figure>
<p>内核与之对应的系统调用是sys_mount()。该函数根据文件 系统类型得到相应的file_system_type 对象,再取得该分区 的超级块对象。</p>
<p>####<strong>系统中断</strong><br>导致缺页异常（缺页中断）的原因有：</p>
<ul>
<li>编程错误。可分为内核程序错误和用户程序错误</li>
<li>操作系统故意引发的异常。操作系统利用硬件机制，在适当时间触发异常，使得该异常的处理程序被调用，以达到预期目的。</li>
</ul>
<p>补充：</p>
<ul>
<li>do_page_fault（）得到的异常发生虚拟地址对于IA32在CR2寄存器中；此函数执行次数可认为系统发生缺页</li>
<li>每个进程都有一个页目录，当进程运行时，寄存器CR3指向该页目录的地址。</li>
<li>系统三级页表：</li>
</ul>
<ul>
<li>页目录PGD</li>
<li>页中间目录PMD</li>
<li>页表PTE</li>
</ul>
<ul>
<li>2.6.11以后Linux采用四级页表模型来使用硬件分页机制，分别是：pgd_t，pud_t，pmd_t，pte_t</li>
<li>Linux使用两个运行模式：特权级0和特权级3，即内核模式和用户模式</li>
<li>每个系统调用号至少有一个参数，即通过eax寄存器传递来的系统调用号</li>
<li>Linux利用守护进程kswapd定期检查系统内的空闲页帧数是否小于预定义的极限，一旦发现空闲帧数太少，就先将若干页换出。kswapd相当于一个进程，它有自己的进程控制块task_struct结构，与其他进程一样同样受内核调度，但没有独立的地址空间</li>
<li>写时拷贝的处理过程</li>
</ul>
<ul>
<li>首先改写对应页表项的访问标志位,表明其刚被访问过,<br>这样在页面调度时该页面就不会被优先考虑。</li>
<li>如果该页帧目前只为一个进程单独使用,则只需把页表项置为可写。</li>
<li>如果该页帧为多个进程共享,则申请一个新的物理页帧并 标记为可写,复制原来物理页帧的内容,更改当前进程相应的页表项,同时原来的物理页帧的共享计数减一。</li>
</ul>
<ul>
<li>按需调页的处理过程</li>
</ul>
<ul>
<li>第一种情况页面从未被进程访问，这种情况页表项的值全部为0</li>
<li>另一种情况是该页面被进程访问过,但是目前已被写到交换 分区, 页表项的存在标志位为0,但其他位被用来记录该页 面在交换分区中的信息。</li>
</ul>
<ul>
<li>伙伴系统的操作：</li>
</ul>
<ul>
<li>申请空间的函数为alloc_pages( );</li>
<li>释放函数为free_pages( );</li>
<li>当在申请内存发现页帧短缺时,还会唤醒kswapd内核线程运行,该线程会腾出一些空间以满足要求。</li>
</ul>
</article></main></body></html>